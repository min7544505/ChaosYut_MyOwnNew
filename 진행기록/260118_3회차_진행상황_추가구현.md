# 3회차 진행상황

**날짜:** 2025-01-18
**세션 시간:** 약 1시간

**출처:** 지식 베이스 "Session Logger Agent" 참조

---

## 오늘 한 일

- [x] **SetupConnections 함수 완전 구현** - BP_YutBoard에서 29개 Road 액터들의 NextRoads, PrevRoads 배열 연결
- [x] **중첩 For Each Loop 패턴 학습** - 외부 Loop(29개 Row) + 내부 Loop(NextRoads, PrevRoads 파싱)
- [x] **Parse Into Array 노드 활용** - 문자열 `"O_P|D_H"`를 배열 `["O_P", "D_H"]`로 변환
- [x] **String To Name 변환 학습** - Map의 Key(Name 타입) 검색을 위한 타입 변환
- [x] **Map의 Value(Object Reference) 개념 이해** - 스폰된 액터의 참조가 저장되는 원리

---

## 결정된 사항

### SetupConnections 함수 구조
- **외부 Loop**: DataTable의 29개 Row를 순회
- **내부 Loop #1**: NextRoads 문자열 파싱 후 액터 연결
- **내부 Loop #2**: PrevRoads 문자열 파싱 후 액터 연결
- 각 Road 액터의 NextRoads, PrevRoads 배열에 실제 액터 참조 저장

---

## 주요 논의 내용

### 1. SetupConnections 함수 단계별 구현

| Step | 작업 내용 |
|------|-----------|
| Step 1 | Get Data Table Row Names로 29개 Row 이름 가져오기 |
| Step 2 | 외부 For Each Loop 설정 |
| Step 3 | Get Data Table Row + Break ST_RoadData |
| Step 4 | Find (Map)으로 CurrentRoad 찾기 |
| Step 5 | NextRoads 파싱 및 연결 (내부 Loop #1) |
| Step 6 | PrevRoads 파싱 및 연결 (내부 Loop #2) |
| Step 7 | Return Node로 함수 완료 |

### 2. C1 데이터 흐름 예시

```
입력: Row Name "0" → RoadID "C1"
      NextRoads: "O_L" → [O_L 액터]
      PrevRoads: "O_P|D_H" → [O_P 액터, D_H 액터]

결과:
C1 (BP_MergeRoad):
├── NextRoads: [O_L 액터] (1개)
└── PrevRoads: [O_P 액터, D_H 액터] (2개 - 합류점이라서)
```

### 3. Object Reference 개념

| 구분 | 저장하는 것 | 비유 |
|------|-------------|------|
| Class Reference | 클래스 정의 (설계도) | "자동차 설계도" |
| Object Reference | 실제 인스턴스 | "내 차 (번호판: 12가 3456)" |

**Map의 Value에 저장되는 것**: SpawnActor로 생성된 Road 액터의 **참조(메모리 주소)**
- 참조가 있으면 액터의 변수/함수에 접근 가능
- 예: `C1액터.NextRoads[0].GetActorLocation()` → 말 이동 위치 획득

---

## 학습 내용 정리

### 새로 배운 노드들

| 노드 | 역할 | 사용 예시 |
|------|------|-----------|
| **Parse Into Array** | 문자열을 구분자로 분리하여 배열 생성 | `"O_P|D_H"` → `["O_P", "D_H"]` |
| **String To Name** | String을 Name 타입으로 변환 | Map의 Key 검색용 |
| **Find (Map)** | Map에서 Key로 Value 검색 | AllRoads에서 RoadID로 액터 찾기 |
| **Add (Array)** | 배열에 요소 추가 | NextRoads/PrevRoads에 액터 추가 |

### 중첩 For Each Loop 실행 순서

```
외부 Loop (29번)
    │
    ├── 1회차: C1 처리
    │       ├── 내부 Loop #1: NextRoads (1번)
    │       └── 내부 Loop #2: PrevRoads (2번)
    │
    ├── 2회차: C2 처리
    │       ├── 내부 Loop #1: NextRoads
    │       └── 내부 Loop #2: PrevRoads
    │
    └── ... 29회차까지
```

---

## 다음에 이어갈 것

- [ ] **SetupConnections 테스트** - 실제로 연결이 잘 되었는지 Print String으로 확인
- [ ] **BP_RoadBase 함수 구현**
  - GetNextRoad(bPreferDiagonal)
  - GetPrevRoad(bPreferDiagonal)
  - OnPieceEnter(Piece)
  - OnPieceExit(Piece)
- [ ] **BP_BranchRoad, BP_MergeRoad, BP_CenterRoad 특수 로직 구현**
- [ ] **말 이동 로직 구현** - Road 연결 정보를 활용한 실제 이동

---

## 파일 구조 (현재 상태)

```
BP_YutBoard
├── Variables
│   ├── BoardLayoutTable (DataTable)
│   ├── AllRoads (Map: Name → BP_RoadBase)
│   ├── StartRoad (BP_RoadBase)
│   ├── RoadBaseClass (Class Reference)
│   ├── BranchRoadClass (Class Reference)
│   ├── MergeRoadClass (Class Reference)
│   └── CenterRoadClass (Class Reference)
│
└── Functions
    ├── InitializeBoard ✅ (완료)
    ├── SpawnRoadByType ✅ (완료)
    └── SetupConnections ✅ (오늘 완료!)
```

---

## 메모

- **합류점(Merge)의 PrevRoads가 2개인 이유**: 외곽 경로와 대각선 경로가 만나는 지점
- **백도 시 경로 선택**: PrevRoads가 여러 개면 플레이어가 선택 가능
- **Object Reference는 전화번호부와 같다**: 번호(참조)가 있으면 그 사람(액터)에게 연락(함수 호출) 가능

---

## 대화 하이라이트

> **Q:** Map의 Value 값으로 SpawnRoadByType에서 나온 값을 넣었는데, 여기에는 정확히 어떤 값이 들어간거야?
>
> **A:** Value에는 **스폰된 액터의 참조(Reference)**가 들어갑니다. 메모리에 있는 실제 액터를 가리키는 "포인터"로, 참조가 있으면 그 액터의 변수/함수에 접근할 수 있습니다.